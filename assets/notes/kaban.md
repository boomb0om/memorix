# Базы данных
## Сетевая и реляционные модели БД (из 1970х)
**Сетевая модель** - что-то типо графа со связями между таблицами, где каждая связь это ссылка (как в языках программирования), при этом родителей у записи может быть много. Программисту нужно было знать точный "путь" до записи, что было сложно.
**Реляционная** - ну тут понятно, в итоге она победила сетевую из-за простоты. Ты просто пишешь запрос, а оптимизатор и планировщик запросов уже определяют "как" они это выполнят, то есть SQL это декларативный язык. А еще выполнение запросов на декларативном языке сильно проще распараллелить горизонтально, чем на императивном ЯП.
## Документные (NoSQL) vs реляционные БД
Что из этого лучше - зависит только и только от приложения и нагрузок.
При выборе остается только смотреть, что из этого важнее для конкретного приложения.
**Документные**:
- Гибкая схема
- Лучше локальность данных
- Быстрее чтение/запись в некоторых случаях благодаря локальности
**Реляционные**:
- Строгая схема
- Позволяет делает сложные запросы и join-ы
- Лучше моделирует сложные связи и домены, особенно связи many2many

При этом, многие NoSQL системы сейчас становятся похожи на SQL БД - туда добавляются ACID транзакции, join-ы и прочее (напр, MongoDB).
## Графовые СУБД
- Модель графа свойств (пример, Neo4j и язык запросов Cypher)
- Модель/хранилище тройных кортежей - по-сути просто альтернативный формат задавания графов
## Индексы
**Хеш-индексы** - очень похож чем-то на SS-таблицы

**SSTable (Sorted String Tables)** - это дисковая структура данных, представляющий собой отсортированную последовательность пар ключ-значение, где каждый ключ уникален и соответствует одному значению.
см. [[SSTable]]

**LSM-деревья (Log-Structured Merge-Tree)** - индекс, основанных поверх SSтаблиц, поддерживающий write-heavy нагрузки.
см. [[LSM-деревья]]

**B-дерево** – это сбалансированное дерево поиска, в котором каждый узел содержит множество ключей и имеет более двух потомков
см. [[B-деревья]]

Как правило, LSM деревья быстрее при записи, B-деревья для чтения. Чтение выполняется на LSM-деревьях медленнее, тк приходится просматривать несколько сегментов разной степени уплотнения. Однако эти оценки не всегда выполняются и нужно смотреть отдельно под каждую систему и рабочую нагрузку.
## DWH
DWH обычно используются как OLAP система для обработки аналитических запросов. Есть несколько способов моделирования DWH, но самые известные из них:
- [[Схема звезда (DWH)]]
- [[Схема снежинка (DWH)]]

Еще про БД и OLAP:
- [[Материализованные представления (БД)]]
- [[OLAP-куб]]

# Кодирование и передача данных

## Типы форматов кодирования данных:
- **Языко-специфичные (pickle)**
  Ограничены только этим языком и обычно не могут обеспечить обратную и прямую совместимость.
- **Текстовые (JSON, XML)**
  Не эффективны, однако хорошо читаются человеком. К тому же могут быть проблемы с интепретированием схемы (путается int и float, проблемы с конвертацией float в текст)
- **Двоичные ([[Protobuf]], Thrift, Apache Avro)**
  Эффективны, хорошо кодируются и сжимаются, однако нужны специально инструменты, чтобы их мог прочитать человек. Также обеспечивают обратную и прямую совместимость.

Эволюция схемы - TODO
## Типы передачи данных:
- Через БД
- Между клиентом и сервером по RPC или REST API
- Асинхронная передача соообщений через брокер
# Распределенные системы
**Зачем хотим?**
- Вертикальное масштабирование не бесконечно
- У пользователей из других стран выше задержка. Хотим иметь части системы в разных ДЦ/странах
- Хотим иметь отказоустойчивость на уровне ДЦ

**Есть два способа распределения данных по нескольким узлам:**
1. **Репликация** - хранится копия на каждом узле
2. **Секционирование** - или же партиционирование, шардирование. Разбивает данные по частям на узлы.
## Replication lag
При асинхронной репликации возможны задержки репликации, может пройти какое-то время прежде чем обновление применится ко всем репликам. При этом пользователь может прочитать обновленные данные прежде чем они успеют обновится на реплике и тем самым пользователь увидит что ничего не обновилось. Эта проблема называется **read-after-write consistency**). Исправить ее можно, если:
1. Читать данные всегда с ведущего узла (например, если таких данных немного)
2. Запоминать время обновления и в течение, например, минуты, читать только с ведущего узла.
То есть какие вообще могут быть аномалии:
- **read-after-write consistency** - пользователь не видит изменений обновленных данных
- **monotonic reads** - пользователь читает несколько раз подряд с разных реплик и получает разные результаты. Чтобы пофиксить, надо закреплять за пользователем реплику
- **consistent prefix reads** - операции записи должны выполняться в одном и том же порядке на всех репликах
## multi-leader репликация
Использовать репликацию с несколькими ведущими узлами в рамках одного в большинстве случаев ЦОД имеет мало смысла.

Какие преимущества использовать несколько мастер-реплик в нескольких ЦОД-ах:
1. **Производительность**
   Несколько мастер-реплик позволяют обработать больше запросов на запись.
2. **Устойчивость к перебоям** в обслуживании ЦОДов
3. **Устойчивость к проблемам с сетью** 
   (при асинхронной репликации между ЦОДами)
## Виды репликации
Есть 3 типа репликации:
1. С одним ведущим узлом и ведомыми узлами
2. С несколькими ведущими узлами (multi-leader)
3. Без ведущего узла (кворум)
## Кворум
w, r, n
